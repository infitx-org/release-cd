# test cases for match function
# test nullish, truthy and falsy values
- {rule: {a: null},                               like: {b: 0},              unlike: {a: false}}
- {rule: {a: null},                               like: {a: null},           unlike: {a: 0}}
- {rule: {a: null},                               like: {a: },               unlike: {a: ''}}
- {rule: {a: null},                               like: {a: [null]},         unlike: {a: {}}}
- {rule: {a: [null, false]},                      like: {a: null},           unlike: {a: 1}}
- {rule: {a: [null, false]},                      like: {},                  unlike: {a: 1}}
- {rule: {a: [null, false]},                      like: {a: ''},             unlike: {a: ' '}}
- {rule: {a: [null, true]},                       like: {a: null},           unlike: {a: 0}}
- {rule: {a: [null, true]},                       like: {},                  unlike: {a: 0}}
- {rule: {a: [null, true]},                       like: {a: ' '},            unlike: {a: ''}}
- {rule: {a: {b: null}},                          like: {a: {}},             unlike: {b: {}}}
- {rule: null,                                    like: null,                unlike: [false, 0, '']}

# test nested nullish, truthy and falsy values
- {rule: {a: {b: null}},                          like: {a: {a: {}}},        unlike: {a: {b: false}}}
- {rule: {a: {b: null}},                          like: {a: {b: null}},      unlike: {a: {b: 0}}}
- {rule: {a: {b: null}},                          like: {a: {b: }},          unlike: {a: {b: ''}}}
- {rule: {a: {b: null}},                          like: {a: {b: [null]}},    unlike: {a: {b: {}}}}
- {rule: {a: {b: [null, false]}},                 like: {a: {b: null}},      unlike: {a: {b: 1}}}
- {rule: {a: {b: [null, false]}},                 like: {a: {}},             unlike: {a: {b: 1}}}
- {rule: {a: {b: [null, false]}},                 like: {a: {b: ''}},        unlike: {a: {b: ' '}}}
- {rule: {a: {b: [null, true]}},                  like: {a: {b: null}},      unlike: {a: {b: 0}}}
- {rule: {a: {b: [null, true]}},                  like: {a: {}},             unlike: {a: {b: 0}}}
- {rule: {a: {b: [null, true]}},                  like: {a: {b: ' '}},       unlike: {a: {b: ''}}}

# test "not" semantic for negation
- {rule: {not: 5},                                like: 3,                   unlike: 5}
- {rule: {not: hello},                            like: goodbye,             unlike: hello}
- {rule: {not: true},                             like: false,               unlike: true}
- {rule: {not: true},                             like: 0,                   unlike: 1}
- {rule: {not: false},                            like: true,                unlike: false}
- {rule: {not: null},                             like: 0,                   unlike: null}
- {rule: {not: null},                             like: false,               unlike: [null]}
- {rule: {a: {not: 5}},                           like: {a: 3},              unlike: {a: 5}}
- {rule: {a: {not: 5}},                           like: {a: 'x'},            unlike: {a: 5}}
- {rule: {a: {not: hello}},                       like: {a: world},          unlike: {a: hello}}
- {rule: {not: /hello/},                          like: goodbye,             unlike: hello world}
- {rule: {a: {not: /foo/}},                       like: {a: bar},            unlike: {a: foo}}
- {rule: {not: [1, 2, 3]},                        like: 5,                   unlike: 2}
- {rule: {not: [1, 2, 3]},                        like: 0,                   unlike: 3}
- {rule: {a: {not: [1, 2, 3]}},                   like: {a: 5},              unlike: {a: 2}}
- {rule: {not: {min: 5, max: 10}},                like: 3,                   unlike: 7}
- {rule: {not: {min: 5, max: 10}},                like: 15,                  unlike: 5}
- {rule: {a: {not: {min: 5}}},                    like: {a: 3},              unlike: {a: 10}}
- {rule: {not: v => v > 5},                       like: 3,                   unlike: 10}
- {rule: {a: {not: v => v > 5}},                  like: {a: 3},              unlike: {a: 10}}
- {rule: {not: {a: 1}},                           like: {a: 2},              unlike: {a: 1}}
- {rule: {not: {a: 1}},                           like: {b: 1},              unlike: {a: 1, b: 2}}
- {rule: {a: {b: {not: 5}}},                      like: {a: {b: 3}},         unlike: {a: {b: 5}}}
- {rule: {not: [true]},                           like: null,                unlike: true}
- {rule: {not: [false]},                          like: 1,                   unlike: 0}

# test Grafana-style time intervals
- {rule: {min: now-1h},                           like: (now) => new Date(now),                             unlike: (now) => new Date(now - 2 * 60 * 60 * 1000)}
- {rule: {max: now},                              like: (now) => new Date(now - 1000),                      unlike: (now) => new Date(now + 1000)}
- {rule: {min: now-1d, max: now+1d},              like: (now) => new Date(now),                             unlike: (now) => new Date(now - 2 * 24 * 60 * 60 * 1000)}
- {rule: {min: now-5m},                           like: (now) => new Date(now - 2 * 60 * 1000),             unlike: (now) => new Date(now - 10 * 60 * 1000)}
- {rule: {max: now+1h},                           like: (now) => new Date(now + 30 * 60 * 1000),            unlike: (now) => new Date(now + 2 * 60 * 60 * 1000)}
- {rule: {min: now-1w, max: now},                 like: (now) => new Date(now - 3 * 24 * 60 * 60 * 1000),   unlike: (now) => new Date(now - 10 * 24 * 60 * 60 * 1000)}
- {rule: {min: now-30s},                          like: (now) => new Date(now - 10 * 1000),                 unlike: (now) => new Date(now - 60 * 1000)}
- {rule: {min: now-1M, max: now+1M},              like: (now) => new Date(now),                             unlike: (now) => new Date(now - 60 * 24 * 60 * 60 * 1000)}
- {rule: {min: now-1y},                           like: (now) => new Date(now - 180 * 24 * 60 * 60 * 1000), unlike: (now) => new Date(now - 400 * 24 * 60 * 60 * 1000)}
- {rule: {a: {min: now-1h}},                      like: {a: (now) => new Date(now)},                        unlike: {a: (now) => new Date(now - 2 * 60 * 60 * 1000)}}
- {rule: {a: {max: now+1d}},                      like: {a: (now) => new Date(now)},                        unlike: {a: (now) => new Date(now + 2 * 24 * 60 * 60 * 1000)}}

# arrays represent "any of" semantics
- {rule: /hello/,                                 like: hello world,         unlike: goodbye}
- {rule: /bar/,                                   like: [foo, bar],          unlike: [foo, baz]}
- {rule: true,                                    like: true,                unlike: false}
- {rule: 2024-06-01,                              like: 2024-06-01,          unlike: 2024-07-01}
- {rule: 2024-06-01,                              like: '2024-06-01',        unlike: '2024-07-01'}
- {rule: v => v > 3,                              like: 5,                   unlike: 2}
- {rule: v => v > 2,                              like: [1, 2, 3],           unlike: [1, 2]}
- {rule: v => v > 2,                              like: [1, 2, 3],           unlike: []}
- {rule: [/bar/, /foo/],                          like: foo,                 unlike: baz}
- {rule: {min: 3, max: 10},                       like: 5,                   unlike: 11}
- {rule: {min: 3, max: 10},                       like: [1, 5],              unlike: [1, 11]}
- {rule: {min: 3},                                like: 5,                   unlike: 2}
- {rule: {max: 10},                               like: 5,                   unlike: 11}
- {rule: {min: 2024-05-01, max: 2024-07-01},      like: 2024-06-01,          unlike: 2024-08-01}
- {rule: {min: '2024-05-01', max: '2024-07-01'},  like: 2024-06-01,          unlike: 2024-08-01}
# partial object matching
- {rule: {a: 1},                                  like: {a: 1, b: 2},        unlike: {a: 2}}
- {rule: {a: 1},                                  like: [{a: 1}, {b: 1}],    unlike: [{a: 2}, {b: 2}]}
- {rule: {a: [2, 3, 4]},                          like: {a: 2, b: 2},        unlike: {a: 1}}
- {rule: {a: {b: 2}},                             like: {a: {b: 2, c: 3}},   unlike: {a: {b: 3}}}
- {rule: {a: {max: 2}},                           like: {a: [2, 3, 4]},      unlike: {a: [3, 4, 5]}}
- {rule: {a: [2]},                                like: {a: [2, 3, 4]},      unlike: {a: [3, 4, 5]}}
# tests with rule arrays
- {rule: [/bar/, /foo/],                          like: [foo, bar],          unlike: [baz, qux]}
- {rule: [1, 2, 3],                               like: 2,                   unlike: 4}
# min tests with infinities (-Infinity is smaller than numbers and +Infinity, but not NaN)
- {rule: {min: .inf},                                                        unlike: 5}
- {rule: {min: .inf},                                                        unlike: .nan}
- {rule: {min: .inf},                                                        unlike: .inf}
- {rule: {min: .inf},                                                        unlike: [5, .nan, .inf]}
- {rule: {min: -.inf},                            like: 5,                   unlike: -.inf}
- {rule: {min: -.inf},                            like: .inf,                unlike: .nan}
- {rule: {min: -.inf},                            like: [5, .inf],           unlike: [-.inf, .nan]}
# max tests with infinities (+Infinity is larger than numbers and -Infinity, but not NaN)
- {rule: {max: .inf},                             like: 5,                   unlike: .inf}
- {rule: {max: .inf},                             like: -.inf,               unlike: .nan}
- {rule: {max: .inf},                             like: [5, -.inf],          unlike: [.inf, .nan]}
- {rule: {max: -.inf},                                                       unlike: 5}
- {rule: {max: -.inf},                                                       unlike: .nan}
- {rule: {max: -.inf},                                                       unlike: -.inf}
- {rule: {max: -.inf},                                                       unlike: [5, .nan, -.inf]}
# min/max tests with strings, including numeric strings
- {rule: {min: a},                                like: c,                   unlike: _}
- {rule: {max: m},                                like: c,                   unlike: z}
- {rule: {min: a, max: m},                        like: d,                   unlike: p}
- {rule: {min: '10', max: '200'},                 like: '100',               unlike: '50'}
- {rule: {min: '2', max: '30'},                   like: '200',               unlike: '5'}
# min/max tests with invalid dates
- {rule: {min: 2024-05-01},                       like: 2024-06-01,          unlike: not a date}
- {rule: {max: 2024-07-01},                       like: 2024-06-01,          unlike: not a date}
# rule with array of two number ranges
- {rule: [{min: 1, max: 5}, {min: 10, max: 15}],  like: 3,                   unlike: 8}
- {rule: [{min: 1, max: 5}, {min: 10, max: 15}],  like: [3, 12],             unlike: [8, 18]}
# rule with array of two string ranges
- {rule: [{min: a, max: e}, {min: k, max: o}],    like: c,                   unlike: h}

# define some reusable rules
- &transfer-rule {type: transfer, amount: {min: 100, max: 1000}} # transfer with amount between 100 and 1000
- &test-rule     {to: Test} # transfer to a Test user
# define some reusable operations
- &ab-500        {type: transfer, amount: 500, from: Alice, to: Bob}
- &ab-50         {type: transfer, amount:  50, from: Alice, to: Bob}
- &ab-pay        {type: payment,  amount: 500, from: Alice, to: Bob}
- &at-pay        {type: payment,  amount:  50, from: Alice, to: Test}

# test single rules
- {rule: *transfer-rule,                          like: *ab-500,            unlike: [ *ab-50, *ab-pay, *at-pay ]}
- {rule: *test-rule,                              like: *at-pay,            unlike: [ *ab-50, *ab-pay ]}
# test disjunctions of the above rules
- {rule: [*transfer-rule, *test-rule],            like: *ab-500,            unlike: *ab-50}
- {rule: [*transfer-rule, *test-rule],            like: *at-pay,            unlike: *ab-pay}
- {rule: guide,                                   like: guide,              unlike: guide ends}


# AI suggested test cases for EFT scenarios: transfers, payments, refunds, failed transactions, limits, currencies

- {rule: {type: transfer, amount: {min: 10}},                       like: {type: transfer, amount: 100},                       unlike: {type: transfer, amount: 5}}
- {rule: {type: transfer, amount: {max: 5000}},                     like: {type: transfer, amount: 4999},                      unlike: {type: transfer, amount: 6000}}
- {rule: {type: payment, to: Merchant},                             like: {type: payment, to: Merchant, amount: 200},          unlike: {type: payment, to: Bob, amount: 200}}
- {rule: {type: refund,    amount: { min: 1 }},                     like: {type: refund, amount: 50  },                        unlike: {type: refund, amount: 0}}
- {rule: {status: failed},                                          like: {type: transfer, status: failed},                    unlike: {type: transfer, status: success}}
- {rule: {type: transfer, currency: USD},                           like: {type: transfer, currency: USD, amount: 100},        unlike: {type: transfer,currency: EUR,amount: 100}}
- {rule: {type: payment, currency: [USD, EUR]},                     like: {type: payment, currency: EUR, amount: 50},          unlike: {type: payment, currency: GBP, amount: 50}}
- {rule: {type: transfer, from: Alice, to: Bob},                    like: {type: transfer, from: Alice, to: Bob, amount: 100}, unlike: {type: transfer, from: Bob, to: Alice, amount: 100}}
- {rule: {type: payment, date: {min: 2024-01-01, max: 2024-12-31}}, like: {type: payment, date: 2024-06-15},                   unlike: {type: payment, date: 2023-12-31}}
- {rule: {type: transfer, note: /rent/},                            like: {type: transfer, note: June rent},                   unlike: {type: transfer, note: utilities}}
- {rule: {type: transfer, amount: {min: 100, max: 1000}},           like: {type: transfer, amount: 500},                       unlike: {type: transfer, amount: 50}}
- {rule: {type: payment, reference: '/^[A-Z]{3}-\d{4}$/'},          like: {type: payment, reference: ABC-1234},                unlike: {type: payment, reference: abc-1234}}
- {rule: {type: refund, to: Alice},                                 like: {type: refund, to: Alice, amount: 50},               unlike: {type: refund, to: Bob, amount: 50}}
- {rule: {type: payment, amount: '500'},                            like: {type: payment, amount: 500},                        unlike: {type: payment, amount: 501}}
- {rule: {type: transfer, metadata: {approved: true}},              like: {type: transfer, metadata: {approved: true, id: 1}}, unlike: {type: transfer, metadata: {approved: false}}}

# from and to are objects with list of tags
- rule:
    type: transfer
    from: {tags: [vip]}
    to: {tags: [business]}
  like:
    type: transfer
    from: {tags: [vip, premium]}
    to: {tags: [business, partner]}
    amount: 100
  unlike:
    type: transfer
    from: {tags: [regular]}
    to: {tags: [business]}
    amount: 100

# more complex rule, which contains spatial data and user defined tags
- rule:
    type: transfer
    from: {location: {city: NYC, country: USA}, tags: [vip, user-defined-tag]}
    to: {location: {city: London, country: UK}, tags: [business, individual]}
  like:
    type: transfer
    from: {name: Alice, location: {city: NYC, country: USA}, tags: [user-defined-tag]}  # ok
    to: {name: Bob, location: {city: London, country: UK}, tags: [business]} # ok
    amount: 200
  unlike:
    type: transfer
    from: {name: Charlie, location: {city: NYC, country: USA}, tags: [regular]}  # missing tag
    to: {name: David, location: {city: London, country: UK}, tags: [individual, user-defined-tag]} # ok
    amount: 200

# Time rounding with "/" operator
# These tests use explicit dates to ensure consistent behavior
# Reference conceptual time: 2025-06-15T14:30:45.500Z (Sunday)

# now/s rounds to start of second
- rule: {min: 'now/s', max: 'now'}
  like: (now) => { new Date(now); }
  unlike: (now) => { new Date(now - 1000); }

- rule: {min: 'now/s', max: 'now/s'}
  like: (now) => { const d = new Date(now); d.setMilliseconds(0); return d; }
# now/m rounds to start of minute
- rule: {min: 'now/m', max: 'now'}
  like: (now) => { new Date(now); }
  unlike: (now) => { new Date(now - 60 * 1000); }

- rule: {min: 'now/m', max: 'now/m'}
  like: (now) => { const d = new Date(now); d.setSeconds(0, 0); return d; }

# now/h rounds to start of hour
- rule: {min: 'now/h', max: 'now'}
  like: (now) => { new Date(now); }
  unlike: (now) => { new Date(now - 60 * 60 * 1000); }

- rule: {min: 'now/h', max: 'now/h'}
  like: (now) => { const d = new Date(now); d.setMinutes(0, 0, 0); return d; }

# now/d rounds to start of day (midnight)
- rule: {min: 'now/d', max: 'now'}
  like: (now) => { new Date(now); }
  unlike: (now) => { new Date(now - 24 * 60 * 60 * 1000); }

- rule: {min: 'now/d', max: 'now/d'}
  like: (now) => { const d = new Date(now); d.setHours(0, 0, 0, 0); return d; }

# now/w rounds to start of week (Monday)
- rule:
    min: 'now/w'
    max: 'now/w'
  like: '(now) => { const d = new Date(now); d.setHours(0, 0, 0, 0); const day = d.getDay(); const diff = day === 0 ? 6 : (day - 1); d.setDate(d.getDate() - diff); return d; }'
  unlike: '(now) => { const d = new Date(now); d.setHours(0, 0, 0, 0); const day = d.getDay(); const diff = day === 0 ? 6 : (day - 1); d.setDate(d.getDate() - diff - 1); return d; }'

# now/M rounds to start of month
- rule: {min: 'now/M', max: 'now/M'}
  like: (now) => { const d = new Date(now); d.setDate(1); d.setHours(0, 0, 0, 0); return d; }
  unlike: (now) => { const d = new Date(now); d.setDate(1); d.setHours(0, 0, 0, 0); d.setDate(d.getDate() - 1); return d; }

# now/y rounds to start of year
- rule: {min: 'now/y', max: 'now/y'}
  like: (now) => { const d = new Date(now); d.setMonth(0, 1); d.setHours(0, 0, 0, 0); return d; }
  unlike: (now) => { const d = new Date(now); d.setMonth(0, 1); d.setHours(0, 0, 0, 0); d.setDate(d.getDate() - 1); return d; }

# now-5d/d rounds 5 days ago to midnight
- rule: {min: 'now-5d/d', max: 'now-5d/d'}
  like: (now) => { const d = new Date(now - 5 * 24 * 60 * 60 * 1000); d.setHours(0, 0, 0, 0); return d; }
  unlike: (now) => { const d = new Date(now - 5 * 24 * 60 * 60 * 1000); d.setHours(0, 0, 0, 1); return d; }

# now-2h/h rounds 2 hours ago to start of hour
- rule: {min: 'now-2h/h', max: 'now-2h/h'}
  like: (now) => { const d = new Date(now - 2 * 60 * 60 * 1000); d.setMinutes(0, 0, 0); return d; }
  unlike: (now) => { const d = new Date(now - 2 * 60 * 60 * 1000); d.setMinutes(0, 0, 1); return d; }

# now-1M/M rounds 1 month ago to start of month
- rule: {min: 'now-1M/M', max: 'now-1M/M'}
  like: (now) => { const d = new Date(now - 30 * 24 * 60 * 60 * 1000); d.setDate(1); d.setHours(0, 0, 0, 0); return d; }
  unlike: (now) => { const d = new Date(now - 30 * 24 * 60 * 60 * 1000); d.setDate(1); d.setHours(0, 0, 0, 1); return d; }

# now+1d/d rounds tomorrow to midnight
- rule: {min: 'now+1d/d', max: 'now+1d/d'}
  like: (now) => { const d = new Date(now + 24 * 60 * 60 * 1000); d.setHours(0, 0, 0, 0); return d; }
  unlike: (now) => { const d = new Date(now + 24 * 60 * 60 * 1000); d.setHours(0, 0, 0, 1); return d; }

# Combined: now-7d/d to now/d covers last 7 full days
- rule: {min: 'now-7d/d', max: 'now/d'}
  like: (now) => { const d = new Date(now - 4 * 24 * 60 * 60 * 1000); return d; }
  unlike: (now) => { const d = new Date(now - 8 * 24 * 60 * 60 * 1000); return d; }

- rule: {min: 'now-7d/d', max: 'now/d'}
  like: (now) => { const d = new Date(now - 7 * 24 * 60 * 60 * 1000); d.setHours(0, 0, 0, 0); return d; }

- rule: {min: 'now-7d/d', max: 'now/d'}
  like: (now) => { const d = new Date(now); d.setHours(0, 0, 0, 0); return d; }

# test $ref feature - reference values from facts
# Basic $ref resolution
- rule: {order: {dateCreated: {min: {$ref: '#/offer/dateCreated'}}}}
  like: {offer: {dateCreated: 2024-01-01}, order: {dateCreated: 2024-02-01}}
  unlike: {offer: {dateCreated: 2024-03-01}, order: {dateCreated: 2024-02-01}}

# $ref with missing property should resolve to undefined
- rule: {order: {dateCreated: {min: {$ref: '#/offer/dateCreated'}}}}
  like: {order: {dateCreated: 2024-02-01}}

# $ref in max condition
- rule: {order: {amount: {max: {$ref: '#/offer/maxAmount'}}}}
  like: {offer: {maxAmount: 1000}, order: {amount: 500}}
  unlike: {offer: {maxAmount: 1000}, order: {amount: 1500}}

# $ref with nested path
- rule: {order: {price: {min: {$ref: '#/config/pricing/minPrice'}}}}
  like: {config: {pricing: {minPrice: 100}}, order: {price: 150}}
  unlike: {config: {pricing: {minPrice: 100}}, order: {price: 50}}

# $ref with both min and max
- rule: {order: {amount: {min: {$ref: '#/limits/min'}, max: {$ref: '#/limits/max'}}}}
  like: {limits: {min: 100, max: 1000}, order: {amount: 500}}
  unlike: {limits: {min: 100, max: 1000}, order: {amount: 50}}

# $ref in simple value comparison
- rule: {order: {status: {$ref: '#/expectedStatus'}}}
  like: {expectedStatus: active, order: {status: active}}
  unlike: {expectedStatus: active, order: {status: pending}}

# $ref with array values
- rule: {order: {tags: {$ref: '#/allowedTag'}}}
  like: {allowedTag: vip, order: {tags: [vip, premium]}}
  unlike: {allowedTag: vip, order: {tags: [regular, standard]}}

# $ref with type coercion
- rule: {order: {amount: {$ref: '#/targetAmount'}}}
  like: {targetAmount: '500', order: {amount: 500}}
  unlike: {targetAmount: '500', order: {amount: 600}}

# $ref referencing missing nested property
- rule: {value: {min: {$ref: '#/config/threshold/value'}}}
  like: {value: 10}

# Multiple $ref in same rule
- rule: {transfer: {from: {$ref: '#/source'}, to: {$ref: '#/destination'}}}
  like: {source: Alice, destination: Bob, transfer: {from: Alice, to: Bob}}
  unlike: {source: Alice, destination: Bob, transfer: {from: Charlie, to: Bob}}
