import * as k8s from '@kubernetes/client-node';
import fs from 'fs';
import path from 'path';
import { v7 as uuid } from 'uuid';

const VULNERABILITY_REPORT_PLURAL = 'vulnerabilitymanifests';
const allureDir = path.resolve('allure-results');

async function getVulnerabilityReports() {
    const k8sConfig = new k8s.KubeConfig();
    k8sConfig.loadFromDefault();
    const k8sApi = k8sConfig.makeApiClient(k8s.CustomObjectsApi);
    const group = 'spdx.softwarecomposition.kubescape.io';
    const version = 'v1beta1';

    const policyReportsRes = await k8sApi.listClusterCustomObject({
        group,
        version,
        plural: VULNERABILITY_REPORT_PLURAL
    });

    const images = Object.entries(policyReportsRes.items.reduce((acc, item) => {
        const imageTag = item.metadata.annotations['kubescape.io/image-tag'];
        if (!acc[imageTag]) acc[imageTag] = [];
        acc[imageTag].push({
            imageTag,
            uid: item.metadata.uid,
            namespace: item.metadata.namespace,
            name: item.metadata.name
        });
        return acc;
    }, {})).sort((a, b) => a[0].localeCompare(b[0])).map(([, value]) => value) || [];

    let time = Date.now();
    const artifacts = {};
    for (const index in images) {
        const { name, namespace, imageTag } = images[index][0];
        console.log(`Processing VulnerabilityReport ${Number(index) + 1} / ${images.length}: ${name}`);
        const manifest = await k8sApi.getNamespacedCustomObject({
            group,
            version,
            plural: VULNERABILITY_REPORT_PLURAL,
            name,
            namespace
        });
        for (const match of manifest?.spec?.payload?.matches || []) {
            const artifactId = decodeURIComponent(match.artifact.purl.split('@')[0]);
            if (!artifacts[artifactId]) {
                artifacts[artifactId] = {
                    uuid: uuid(),
                    name: artifactId.split('/').pop(),
                    titlePath: artifactId.split('/').slice(0, -1),
                    fullName: artifactId,
                    stage: 'finished',
                    start: time,
                    vulnerabilities: {}
                };
                time = Date.now();
                artifacts[artifactId].stop = time;
            }
            const vulnerabilities = artifacts[artifactId].vulnerabilities;
            const version = match.artifact.version;
            const vulnerabilityId = match.vulnerability.id;
            const severityIcon = {
                'critical': 'ðŸ›‘',
                'high': 'ðŸ”´',
                'medium': 'ðŸŸ ',
                'low': 'ðŸŸ¡',
                'info': 'ðŸ”µ'
            }[(match.vulnerability.severity || '').toLowerCase()] || 'âšª';
            if (!vulnerabilities[vulnerabilityId]) vulnerabilities[vulnerabilityId] = {
                name: `${severityIcon} ${match.vulnerability.description || vulnerabilityId} (${match.vulnerability.severity || 'Unknown'})`.trim(),
                message: match.vulnerability.dataSource,
                status: 'failed',
                type: 'step',
                start: time,
                stop: time,
                occurrences: new Set()
            };
            vulnerabilities[vulnerabilityId].occurrences.add(`${imageTag} => ${version}`);
        }
    }
    return artifacts;
}

async function writeAllureResults(artifacts) {
    for (const artifactId in artifacts) {
        const { uuid, name, titlePath, fullName, stage, vulnerabilities, start, stop } = artifacts[artifactId];
        const filename = `${uuid}-result.json`;
        const filepath = path.join(allureDir, filename);
        fs.writeFileSync(filepath, JSON.stringify({
            uuid: artifactId,
            name,
            titlePath,
            fullName,
            stage,
            start,
            stop,
            status: 'failed',
            steps: Object.values(vulnerabilities).map(vuln => ({
                name: vuln.name,
                status: vuln.status,
                type: vuln.type,
                start: vuln.start,
                stop: vuln.stop,
                statusDetails: {
                    message: vuln.message,
                    trace: `Found in:\n\n${Array.from(vuln.occurrences).sort().join('\n')}`
                }
            }))
        }, null, 2));
    }
};

async function main() {
    if (!fs.existsSync(allureDir)) fs.mkdirSync(allureDir, { recursive: true });
    writeAllureResults(await getVulnerabilityReports());
}

main().catch(err => {
    console.error('Error extracting policy reports:', err);
    process.exit(1);
});
